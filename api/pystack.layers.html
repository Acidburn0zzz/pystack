


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>layers Package &mdash; PyStack 1 documentation</title>
    
    <link rel="stylesheet" href="../static/cloud.css" type="text/css" />
    <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Noticia+Text|Open+Sans|Droid+Sans+Mono" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../static/jquery.js"></script>
    <script type="text/javascript" src="../static/underscore.js"></script>
    <script type="text/javascript" src="../static/doctools.js"></script>
    <script type="text/javascript" src="../static/jquery.cookie.js"></script>
    <script type="text/javascript" src="../static/cloud.js"></script>
    <link rel="top" title="PyStack 1 documentation" href="../index.html" /> 
        <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>
  <body>
    <div class="relbar-top">
        
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> &nbsp; &nbsp;</li>
    <li><a href="../index.html">PyStack 1 documentation</a> &raquo;</li>
 
      </ul>
    </div>
    </div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="layers-package">
<h1>layers Package<a class="headerlink" href="#layers-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id1">
<h2><tt class="xref py py-mod docutils literal"><span class="pre">layers</span></tt> Package<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-pystack.layers"></span><p>Author: Robin David
License: GNU GPLv3
Repo: <a class="reference external" href="https://github.com/RobinDavid">https://github.com/RobinDavid</a></p>
<p>Copyright (c) 2012 Robin David</p>
<p>PyStack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or 
any later version <a class="reference external" href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
</div>
<div class="section" id="module-pystack.layers.arp">
<span id="arp-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">arp</span></tt> Module<a class="headerlink" href="#module-pystack.layers.arp" title="Permalink to this headline">¶</a></h2>
<p>Author: Robin David
License: GNU GPLv3
Repo: <a class="reference external" href="https://github.com/RobinDavid">https://github.com/RobinDavid</a></p>
<p>Copyright (c) 2012 Robin David</p>
<p>PyStack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or 
any later version <a class="reference external" href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
<dl class="class">
<dt id="pystack.layers.arp.ARPProtocol">
<em class="property">class </em><tt class="descclassname">pystack.layers.arp.</tt><tt class="descname">ARPProtocol</tt><big>(</big><em>iface</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/arp.html#ARPProtocol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.arp.ARPProtocol" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pystack.layers.layer.Layer" title="pystack.layers.layer.Layer"><tt class="xref py py-class docutils literal"><span class="pre">pystack.layers.layer.Layer</span></tt></a></p>
<p>Provides the basic functionalities provided by the
ARP Protocol. It implements Layer. It keeps an ARP cache
which is updated when an ARP reply is received. It also provides
methods to do ARP request.</p>
<dl class="method">
<dt id="pystack.layers.arp.ARPProtocol.get_mac">
<tt class="descname">get_mac</tt><big>(</big><em>ip</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/arp.html#ARPProtocol.get_mac"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.arp.ARPProtocol.get_mac" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the MAC address associated with the given IP if present.
Otherwise it returns None.</p>
</dd></dl>

<dl class="attribute">
<dt id="pystack.layers.arp.ARPProtocol.name">
<tt class="descname">name</tt><em class="property"> = 'ARP'</em><a class="headerlink" href="#pystack.layers.arp.ARPProtocol.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pystack.layers.arp.ARPProtocol.packet_received">
<tt class="descname">packet_received</tt><big>(</big><em>packet</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/arp.html#ARPProtocol.packet_received"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.arp.ARPProtocol.packet_received" title="Permalink to this definition">¶</a></dt>
<dd><p>Deal with an ARP packet received. If this is a reply
(is_at) update the cache and call route_update that will
flush potential packet waiting for MAC resolution. If the
packet is a request (who_has) and for our MAC reply.</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.arp.ARPProtocol.send_arp_request">
<tt class="descname">send_arp_request</tt><big>(</big><em>ip</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/arp.html#ARPProtocol.send_arp_request"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.arp.ARPProtocol.send_arp_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Send an ARP request on the broadcast for the requested IP</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.arp.ARPProtocol.update_cache">
<tt class="descname">update_cache</tt><big>(</big><em>ip</em>, <em>addr</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/arp.html#ARPProtocol.update_cache"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.arp.ARPProtocol.update_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the cache with the given IP and MAC.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pystack.layers.dns">
<span id="dns-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">dns</span></tt> Module<a class="headerlink" href="#module-pystack.layers.dns" title="Permalink to this headline">¶</a></h2>
<p>Author: Robin David
License: GNU GPLv3
Repo: <a class="reference external" href="https://github.com/RobinDavid">https://github.com/RobinDavid</a></p>
<p>Copyright (c) 2012 Robin David</p>
<p>PyStack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or 
any later version <a class="reference external" href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
<dl class="class">
<dt id="pystack.layers.dns.DNSProtocol">
<em class="property">class </em><tt class="descclassname">pystack.layers.dns.</tt><tt class="descname">DNSProtocol</tt><big>(</big><em>iface=None</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/dns.html#DNSProtocol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.dns.DNSProtocol" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pystack.layers.udp_application.UDPApplication" title="pystack.layers.udp_application.UDPApplication"><tt class="xref py py-class docutils literal"><span class="pre">pystack.layers.udp_application.UDPApplication</span></tt></a></p>
<p>Provide basic DNS implementation. It can
send DNS request to resolve an hostname, and process
replies sent by the server. The server used is a server of 
OpenDNS</p>
<dl class="method">
<dt id="pystack.layers.dns.DNSProtocol.forge_packet">
<tt class="descname">forge_packet</tt><big>(</big><em>packet=None</em>, <em>**fields</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/dns.html#DNSProtocol.forge_packet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.dns.DNSProtocol.forge_packet" title="Permalink to this definition">¶</a></dt>
<dd><p>Just forge the DNS packet with arguments sent in <a href="#id2"><span class="problematic" id="id3">**</span></a>field</p>
</dd></dl>

<dl class="attribute">
<dt id="pystack.layers.dns.DNSProtocol.name">
<tt class="descname">name</tt><em class="property"> = 'DNS'</em><a class="headerlink" href="#pystack.layers.dns.DNSProtocol.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pystack.layers.dns.DNSProtocol.nslookup">
<tt class="descname">nslookup</tt><big>(</big><em>name</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/dns.html#DNSProtocol.nslookup"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.dns.DNSProtocol.nslookup" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a DNS request to resolve a domain name</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.dns.DNSProtocol.packet_received">
<tt class="descname">packet_received</tt><big>(</big><em>packet</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/dns.html#DNSProtocol.packet_received"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.dns.DNSProtocol.packet_received" title="Permalink to this definition">¶</a></dt>
<dd><p>Process DNS packets. But process only incoming answers
for which we made a request</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.dns.DNSProtocol.send_dns_request">
<tt class="descname">send_dns_request</tt><big>(</big><em>name</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/dns.html#DNSProtocol.send_dns_request"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.dns.DNSProtocol.send_dns_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Craft and send a DNS request for the given name</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pystack.layers.ethernet">
<span id="ethernet-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">ethernet</span></tt> Module<a class="headerlink" href="#module-pystack.layers.ethernet" title="Permalink to this headline">¶</a></h2>
<p>Author: Robin David
License: GNU GPLv3
Repo: <a class="reference external" href="https://github.com/RobinDavid">https://github.com/RobinDavid</a></p>
<p>Copyright (c) 2012 Robin David</p>
<p>PyStack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or 
any later version <a class="reference external" href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
<dl class="class">
<dt id="pystack.layers.ethernet.EthernetProtocol">
<em class="property">class </em><tt class="descclassname">pystack.layers.ethernet.</tt><tt class="descname">EthernetProtocol</tt><big>(</big><em>interface=None</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/ethernet.html#EthernetProtocol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.ethernet.EthernetProtocol" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pystack.layers.layer.Layer" title="pystack.layers.layer.Layer"><tt class="xref py py-class docutils literal"><span class="pre">pystack.layers.layer.Layer</span></tt></a></p>
<p>This class provides all the functionalities to accomplish
the layer 2 routing. When a packet is received from an upper layer
this class basically look up in the host routing table to get the ip
to send the packet to and if the mac address is not found trigger an 
ARP request. It also maintain a pool of packet for which the destination
MAC address is unknown until an ARP reply is received.</p>
<dl class="method">
<dt id="pystack.layers.ethernet.EthernetProtocol.forge_packet">
<tt class="descname">forge_packet</tt><big>(</big><em>packet</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/ethernet.html#EthernetProtocol.forge_packet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.ethernet.EthernetProtocol.forge_packet" title="Permalink to this definition">¶</a></dt>
<dd><p>Forge the Ethernet packet using the given kwargs and the given packet</p>
</dd></dl>

<dl class="attribute">
<dt id="pystack.layers.ethernet.EthernetProtocol.name">
<tt class="descname">name</tt><em class="property"> = 'Ether'</em><a class="headerlink" href="#pystack.layers.ethernet.EthernetProtocol.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pystack.layers.ethernet.EthernetProtocol.packet_received">
<tt class="descname">packet_received</tt><big>(</big><em>packet</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/ethernet.html#EthernetProtocol.packet_received"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.ethernet.EthernetProtocol.packet_received" title="Permalink to this definition">¶</a></dt>
<dd><p>Decapsulate the packet as the Layer would have done except that if
the packet is an IP packet this method update the ARP cache with ip and mac</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.ethernet.EthernetProtocol.route_update">
<tt class="descname">route_update</tt><big>(</big><em>ip</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/ethernet.html#EthernetProtocol.route_update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.ethernet.EthernetProtocol.route_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Method called by arp layer when receive an arp reply (is_at)
Loop through all packets if the newly resolved MAC match dst of on of
them complete the packet and send it.</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.ethernet.EthernetProtocol.send_packet">
<tt class="descname">send_packet</tt><big>(</big><em>packet</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/ethernet.html#EthernetProtocol.send_packet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.ethernet.EthernetProtocol.send_packet" title="Permalink to this definition">¶</a></dt>
<dd><p>When a packet is received from an upper layer try to route it. If
the method return something call forge and transfert it (to scapyio)</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.ethernet.EthernetProtocol.start_listening">
<tt class="descname">start_listening</tt><big>(</big><em>doreactor=True</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/ethernet.html#EthernetProtocol.start_listening"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.ethernet.EthernetProtocol.start_listening" title="Permalink to this definition">¶</a></dt>
<dd><p>Because Ethernet have directly the ScapyIO as a class attribute it should
interface ScapyIO methods. This method should be called to start listening
on the socket using the appropriate method (twisted reactor or threads)</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.ethernet.EthernetProtocol.stop">
<tt class="descname">stop</tt><big>(</big><big>)</big><a class="reference internal" href="../modules/pystack/layers/ethernet.html#EthernetProtocol.stop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.ethernet.EthernetProtocol.stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Call the stop method of ScapyIO</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.ethernet.EthernetProtocol.transfer_packet">
<tt class="descname">transfer_packet</tt><big>(</big><em>packet</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/ethernet.html#EthernetProtocol.transfer_packet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.ethernet.EthernetProtocol.transfer_packet" title="Permalink to this definition">¶</a></dt>
<dd><p>Rewrite transfer to use scapy_io because ethernet is the lowest layer.
So in this case call the send method of Scapy</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pystack.layers.ip">
<span id="ip-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">ip</span></tt> Module<a class="headerlink" href="#module-pystack.layers.ip" title="Permalink to this headline">¶</a></h2>
<p>Author: Robin David
License: GNU GPLv3
Repo: <a class="reference external" href="https://github.com/RobinDavid">https://github.com/RobinDavid</a></p>
<p>Copyright (c) 2012 Robin David</p>
<p>PyStack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or 
any later version <a class="reference external" href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
<dl class="class">
<dt id="pystack.layers.ip.IPProtocol">
<em class="property">class </em><tt class="descclassname">pystack.layers.ip.</tt><tt class="descname">IPProtocol</tt><big>(</big><em>method='last'</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/ip.html#IPProtocol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.ip.IPProtocol" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pystack.layers.layer.Layer" title="pystack.layers.layer.Layer"><tt class="xref py py-class docutils literal"><span class="pre">pystack.layers.layer.Layer</span></tt></a></p>
<p>IPProtocol assure the routing at the layer 3 IP.</p>
<dl class="method">
<dt id="pystack.layers.ip.IPProtocol.forge_packet">
<tt class="descname">forge_packet</tt><big>(</big><em>packet</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/ip.html#IPProtocol.forge_packet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.ip.IPProtocol.forge_packet" title="Permalink to this definition">¶</a></dt>
<dd><p>Just forge the packet id the associated arguments</p>
</dd></dl>

<dl class="attribute">
<dt id="pystack.layers.ip.IPProtocol.name">
<tt class="descname">name</tt><em class="property"> = 'IP'</em><a class="headerlink" href="#pystack.layers.ip.IPProtocol.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pystack.layers.ip.IPProtocol.packet_received">
<tt class="descname">packet_received</tt><big>(</big><em>packet</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/ip.html#IPProtocol.packet_received"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.ip.IPProtocol.packet_received" title="Permalink to this definition">¶</a></dt>
<dd><p>Call the right handler but also add the source and destination IP as kwargs otherwise
after decapsulation it will be lost and upper layers need to get it</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.ip.IPProtocol.send_packet">
<tt class="descname">send_packet</tt><big>(</big><em>packet</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/ip.html#IPProtocol.send_packet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.ip.IPProtocol.send_packet" title="Permalink to this definition">¶</a></dt>
<dd><p>If the destination is an IP just transfert it.
If this is an DN try to get the IP otherwise put the packet in the
pool and trigger a DNS request for the given DN</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pystack.layers.layer">
<span id="layer-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">layer</span></tt> Module<a class="headerlink" href="#module-pystack.layers.layer" title="Permalink to this headline">¶</a></h2>
<p>Author: Robin David
License: GNU GPLv3
Repo: <a class="reference external" href="https://github.com/RobinDavid">https://github.com/RobinDavid</a></p>
<p>Copyright (c) 2012 Robin David</p>
<p>PyStack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or 
any later version <a class="reference external" href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
<dl class="class">
<dt id="pystack.layers.layer.Default">
<em class="property">class </em><tt class="descclassname">pystack.layers.layer.</tt><tt class="descname">Default</tt><a class="reference internal" href="../modules/pystack/layers/layer.html#Default"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.layer.Default" title="Permalink to this definition">¶</a></dt>
<dd><p>Default implements Layer. It just override packet_received
to do nothing. Class called when there is not handler for the packet</p>
<dl class="method">
<dt id="pystack.layers.layer.Default.packet_received">
<tt class="descname">packet_received</tt><big>(</big><em>packet</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/layer.html#Default.packet_received"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.layer.Default.packet_received" title="Permalink to this definition">¶</a></dt>
<dd><p>Does nothing. Is called for every packet that does not have any handler</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pystack.layers.layer.Layer">
<em class="property">class </em><tt class="descclassname">pystack.layers.layer.</tt><tt class="descname">Layer</tt><a class="reference internal" href="../modules/pystack/layers/layer.html#Layer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.layer.Layer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Mother class for all the layers(protocols) of the stack.
It provides many methods to register an upper or lower layer.
Moreover it provides methods that should be overriden by
children layers according to theirs behavior.
By the way Layer is an &#8220;abstract&#8221; class it should not be instanciated</p>
<dl class="method">
<dt id="pystack.layers.layer.Layer.forge_packet">
<tt class="descname">forge_packet</tt><big>(</big><em>packet</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/layer.html#Layer.forge_packet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.layer.Layer.forge_packet" title="Permalink to this definition">¶</a></dt>
<dd><p>By default does nothing but should be overriden by child class</p>
</dd></dl>

<dl class="attribute">
<dt id="pystack.layers.layer.Layer.name">
<tt class="descname">name</tt><em class="property"> = ''</em><a class="headerlink" href="#pystack.layers.layer.Layer.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pystack.layers.layer.Layer.packet_received">
<tt class="descname">packet_received</tt><big>(</big><em>packet</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/layer.html#Layer.packet_received"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.layer.Layer.packet_received" title="Permalink to this definition">¶</a></dt>
<dd><p>Define the default behavior when a packet is received. By default decapsulate the packet
and send the payload to the upperlayer referenced by the payload name (TCP, IP ..)</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.layer.Layer.register_layer">
<tt class="descname">register_layer</tt><big>(</big><em>layer</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/layer.html#Layer.register_layer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.layer.Layer.register_layer" title="Permalink to this definition">¶</a></dt>
<dd><p>Shortcut for register_layer_full using the layer.name as key</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.layer.Layer.register_layer_full">
<tt class="descname">register_layer_full</tt><big>(</big><em>name</em>, <em>layer</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/layer.html#Layer.register_layer_full"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.layer.Layer.register_layer_full" title="Permalink to this definition">¶</a></dt>
<dd><p>Shortcut method to register the given layer as upperlayer
and register self as the default lowerlayer for layer.
This can not be used in all cases</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.layer.Layer.register_lower_layer">
<tt class="descname">register_lower_layer</tt><big>(</big><em>name</em>, <em>layer</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/layer.html#Layer.register_lower_layer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.layer.Layer.register_lower_layer" title="Permalink to this definition">¶</a></dt>
<dd><p>Register the given layer in the lowerlayers dict
using the given name as key</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.layer.Layer.register_upper_layer">
<tt class="descname">register_upper_layer</tt><big>(</big><em>name</em>, <em>layer</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/layer.html#Layer.register_upper_layer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.layer.Layer.register_upper_layer" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the given layer into the upperlayers dict
using the given name as key</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.layer.Layer.send_packet">
<tt class="descname">send_packet</tt><big>(</big><em>packet</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/layer.html#Layer.send_packet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.layer.Layer.send_packet" title="Permalink to this definition">¶</a></dt>
<dd><p>By default when calling send_packet it forge the packet calling
forge_packet and forward it to the lower layer calling transfer_packet</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.layer.Layer.transfer_packet">
<tt class="descname">transfer_packet</tt><big>(</big><em>packet</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/layer.html#Layer.transfer_packet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.layer.Layer.transfer_packet" title="Permalink to this definition">¶</a></dt>
<dd><p>Define the default behavior when a packet should be transfered to the lower layer.
The default behavior is to call the send_packet of the default lowerlayer. This method
can be overriden by child layers</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.layer.Layer.unregister_upper_layer">
<tt class="descname">unregister_upper_layer</tt><big>(</big><em>name</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/layer.html#Layer.unregister_upper_layer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.layer.Layer.unregister_upper_layer" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the the layer referenced by the name in upperlayer.
The exception is catched to prevent to make the program crash</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pystack.layers.scapy_io">
<span id="scapy-io-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">scapy_io</span></tt> Module<a class="headerlink" href="#module-pystack.layers.scapy_io" title="Permalink to this headline">¶</a></h2>
<p>Author: Robin David
License: GNU GPLv3
Repo: <a class="reference external" href="https://github.com/RobinDavid">https://github.com/RobinDavid</a></p>
<p>Copyright (c) 2012 Robin David</p>
<p>PyStack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or 
any later version <a class="reference external" href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
<dl class="class">
<dt id="pystack.layers.scapy_io.ScapyIO">
<em class="property">class </em><tt class="descclassname">pystack.layers.scapy_io.</tt><tt class="descname">ScapyIO</tt><big>(</big><em>interface=None</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/scapy_io.html#ScapyIO"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.scapy_io.ScapyIO" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">twisted.internet.base.BasePort</span></tt></p>
<p>SacpyIO play the role of interface with Input/Output functions
of Scapy. So all the packets that are received and sent pass
through here. To receive packet ScapyIO use a L2ListenSocket object.
Then to read packets two methods are implemented, either twisted reactor
add a reader on the socket or a thread that will loop reading packet in
the socket. To send packet the sendp method is called</p>
<dl class="method">
<dt id="pystack.layers.scapy_io.ScapyIO.doRead">
<tt class="descname">doRead</tt><big>(</big><big>)</big><a class="reference internal" href="../modules/pystack/layers/scapy_io.html#ScapyIO.doRead"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.scapy_io.ScapyIO.doRead" title="Permalink to this definition">¶</a></dt>
<dd><p>Method called when the reader read a packet
in the socket. So basically forward it to the 
handler(s)</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.scapy_io.ScapyIO.fileno">
<tt class="descname">fileno</tt><big>(</big><big>)</big><a class="reference internal" href="../modules/pystack/layers/scapy_io.html#ScapyIO.fileno"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.scapy_io.ScapyIO.fileno" title="Permalink to this definition">¶</a></dt>
<dd><p>Needed for the reader</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.scapy_io.ScapyIO.register_handler">
<tt class="descname">register_handler</tt><big>(</big><em>handler</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/scapy_io.html#ScapyIO.register_handler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.scapy_io.ScapyIO.register_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>Register an handler for the packet received. We can put multiples
ones but in the classical case there will be one which is the Ethernet
layer.</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.scapy_io.ScapyIO.send">
<tt class="descname">send</tt><big>(</big><em>packet</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/scapy_io.html#ScapyIO.send"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.scapy_io.ScapyIO.send" title="Permalink to this definition">¶</a></dt>
<dd><p>Send the given packet without any kind of test</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.scapy_io.ScapyIO.start_listening">
<tt class="descname">start_listening</tt><big>(</big><em>doreactor=True</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/scapy_io.html#ScapyIO.start_listening"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.scapy_io.ScapyIO.start_listening" title="Permalink to this definition">¶</a></dt>
<dd><p>Start listening on the socket using the appropriate method.
If reactor is choosen it adds a reader on the socket and create
a callback that will be able to check with the user want to stop.
Note that signalHandlers are disabled for the reactor.
If not reactor is choosen then a thread is used and will be started
enclosed in the _do_read_thread method.</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.scapy_io.ScapyIO.stop_listening">
<tt class="descname">stop_listening</tt><big>(</big><big>)</big><a class="reference internal" href="../modules/pystack/layers/scapy_io.html#ScapyIO.stop_listening"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.scapy_io.ScapyIO.stop_listening" title="Permalink to this definition">¶</a></dt>
<dd><p>Just put the boolean to True. Then the reader
or the thread will have to notice it. Note that
it can take a while because with threads, the thread
is blocked in the recv method until a packet is received</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pystack.layers.tcp">
<span id="tcp-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">tcp</span></tt> Module<a class="headerlink" href="#module-pystack.layers.tcp" title="Permalink to this headline">¶</a></h2>
<p>Author: Robin David
License: GNU GPLv3
Repo: <a class="reference external" href="https://github.com/RobinDavid">https://github.com/RobinDavid</a></p>
<p>Copyright (c) 2012 Robin David</p>
<p>PyStack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or 
any later version <a class="reference external" href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
<dl class="class">
<dt id="pystack.layers.tcp.TCPProtocol">
<em class="property">class </em><tt class="descclassname">pystack.layers.tcp.</tt><tt class="descname">TCPProtocol</tt><a class="reference internal" href="../modules/pystack/layers/tcp.html#TCPProtocol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp.TCPProtocol" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pystack.layers.layer.Layer" title="pystack.layers.layer.Layer"><tt class="xref py py-class docutils literal"><span class="pre">pystack.layers.layer.Layer</span></tt></a></p>
<p>TCPProtocol assure routing functions of
the TCP protocol. It basically route packets to
the right tcp session.</p>
<dl class="method">
<dt id="pystack.layers.tcp.TCPProtocol.forge_packet">
<tt class="descname">forge_packet</tt><big>(</big><em>packet</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp.html#TCPProtocol.forge_packet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp.TCPProtocol.forge_packet" title="Permalink to this definition">¶</a></dt>
<dd><p>Forge the TCP packet with the given argument and the 
payload if present</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.tcp.TCPProtocol.is_port_free">
<tt class="descname">is_port_free</tt><big>(</big><em>p</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp.html#TCPProtocol.is_port_free"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp.TCPProtocol.is_port_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Loop through all the connections to check that the
given port is free. Note this method does not take in
account real connection made by the kernel</p>
</dd></dl>

<dl class="attribute">
<dt id="pystack.layers.tcp.TCPProtocol.name">
<tt class="descname">name</tt><em class="property"> = 'TCP'</em><a class="headerlink" href="#pystack.layers.tcp.TCPProtocol.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pystack.layers.tcp.TCPProtocol.packet_received">
<tt class="descname">packet_received</tt><big>(</big><em>packet</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp.html#TCPProtocol.packet_received"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp.TCPProtocol.packet_received" title="Permalink to this definition">¶</a></dt>
<dd><p>When a packet is received if upper layer contains an
entry like (srcip,srcport,dstip,dstport) the packet is sent to
it otherwise else check (dstip,dstport) if a server is registered.</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.tcp.TCPProtocol.send_packet">
<tt class="descname">send_packet</tt><big>(</big><em>packet</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp.html#TCPProtocol.send_packet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp.TCPProtocol.send_packet" title="Permalink to this definition">¶</a></dt>
<dd><p>Call forge and ten call transfert packet.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pystack.layers.tcp_application">
<span id="tcp-application-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">tcp_application</span></tt> Module<a class="headerlink" href="#module-pystack.layers.tcp_application" title="Permalink to this headline">¶</a></h2>
<p>Author: Robin David
License: GNU GPLv3
Repo: <a class="reference external" href="https://github.com/RobinDavid">https://github.com/RobinDavid</a></p>
<p>Copyright (c) 2012 Robin David</p>
<p>PyStack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or 
any later version <a class="reference external" href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
<dl class="class">
<dt id="pystack.layers.tcp_application.TCPApplication">
<em class="property">class </em><tt class="descclassname">pystack.layers.tcp_application.</tt><tt class="descname">TCPApplication</tt><a class="reference internal" href="../modules/pystack/layers/tcp_application.html#TCPApplication"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_application.TCPApplication" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pystack.layers.layer.Layer" title="pystack.layers.layer.Layer"><tt class="xref py py-class docutils literal"><span class="pre">pystack.layers.layer.Layer</span></tt></a></p>
<p>TCPApplication provides the functionnalities for layer 7
protocols. So there is just connection management and buffer
reading/writing. Moreover for connection management it basically
just call the ones from tcpsession which really do the stuff.</p>
<dl class="method">
<dt id="pystack.layers.tcp_application.TCPApplication.accept">
<tt class="descname">accept</tt><big>(</big><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_application.html#TCPApplication.accept"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_application.TCPApplication.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Call the TCPSession accept method</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.tcp_application.TCPApplication.bind">
<tt class="descname">bind</tt><big>(</big><em>port</em>, <em>app=None</em>, <em>newinstance=False</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_application.html#TCPApplication.bind"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_application.TCPApplication.bind" title="Permalink to this definition">¶</a></dt>
<dd><p>Call the bind method of TCPSession with attributes. Be careful
it is really important to understand what are attributes:</p>
<ul class="simple">
<li>app: Should be a TCPApplication. So that all the clients that will</li>
</ul>
<p>connect the server will be attached to this tcpapplication
If no app is provided the tcpapplication used is self !
- newinstance: Define if all the clients should be linked on the same
tcpapplication (attribute app) or if should be forked for each.</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.tcp_application.TCPApplication.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_application.html#TCPApplication.close"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_application.TCPApplication.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Call the close of the tcpsession</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.tcp_application.TCPApplication.connect">
<tt class="descname">connect</tt><big>(</big><em>ip</em>, <em>port</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_application.html#TCPApplication.connect"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_application.TCPApplication.connect" title="Permalink to this definition">¶</a></dt>
<dd><p>Just call the connect method of TCPSession layer</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.tcp_application.TCPApplication.connection_made">
<tt class="descname">connection_made</tt><big>(</big><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_application.html#TCPApplication.connection_made"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_application.TCPApplication.connection_made" title="Permalink to this definition">¶</a></dt>
<dd><p>By default does nothing, but could be important
in some layer 7 implementation like SSH ..</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.tcp_application.TCPApplication.fetch_data">
<tt class="descname">fetch_data</tt><big>(</big><em>size=None</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_application.html#TCPApplication.fetch_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_application.TCPApplication.fetch_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Fetch_data acquire the mutex in order to pop data
of the wanted size. If no size is specified return all
the datas</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.tcp_application.TCPApplication.fetch_data_from">
<tt class="descname">fetch_data_from</tt><big>(</big><em>size=None</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_application.html#TCPApplication.fetch_data_from"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_application.TCPApplication.fetch_data_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Shortcut for the pysocket module</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.tcp_application.TCPApplication.forge_packet">
<tt class="descname">forge_packet</tt><big>(</big><em>data</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_application.html#TCPApplication.forge_packet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_application.TCPApplication.forge_packet" title="Permalink to this definition">¶</a></dt>
<dd><p>Forge the Raw packet using the datas given in parameter</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.tcp_application.TCPApplication.get_conn_addr">
<tt class="descname">get_conn_addr</tt><big>(</big><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_application.html#TCPApplication.get_conn_addr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_application.TCPApplication.get_conn_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return remote IP and remote Port</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.tcp_application.TCPApplication.get_self_addr">
<tt class="descname">get_self_addr</tt><big>(</big><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_application.html#TCPApplication.get_self_addr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_application.TCPApplication.get_self_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return our IP and the port associated</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.tcp_application.TCPApplication.hook_incoming">
<tt class="descname">hook_incoming</tt><big>(</big><em>packet</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_application.html#TCPApplication.hook_incoming"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_application.TCPApplication.hook_incoming" title="Permalink to this definition">¶</a></dt>
<dd><p>Method called by tcpsession when a packet is received. Can be overriden to apply operation on incoming packets</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.tcp_application.TCPApplication.hook_outgoing">
<tt class="descname">hook_outgoing</tt><big>(</big><em>packet</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_application.html#TCPApplication.hook_outgoing"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_application.TCPApplication.hook_outgoing" title="Permalink to this definition">¶</a></dt>
<dd><p>Method called by tcpsession just before a tcp packet is crafted and sent</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.tcp_application.TCPApplication.listen">
<tt class="descname">listen</tt><big>(</big><em>nb=0</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_application.html#TCPApplication.listen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_application.TCPApplication.listen" title="Permalink to this definition">¶</a></dt>
<dd><p>Just call the listen method of TCPSession layer</p>
</dd></dl>

<dl class="attribute">
<dt id="pystack.layers.tcp_application.TCPApplication.name">
<tt class="descname">name</tt><em class="property"> = 'Raw'</em><a class="headerlink" href="#pystack.layers.tcp_application.TCPApplication.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pystack.layers.tcp_application.TCPApplication.packet_received">
<tt class="descname">packet_received</tt><big>(</big><em>packet</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_application.html#TCPApplication.packet_received"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_application.TCPApplication.packet_received" title="Permalink to this definition">¶</a></dt>
<dd><p>At this level a packet is Raw data so bytes. This
method acquire the mutex add received datas and release the
mutex.</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.tcp_application.TCPApplication.transfer_packet">
<tt class="descname">transfer_packet</tt><big>(</big><em>packet</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_application.html#TCPApplication.transfer_packet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_application.TCPApplication.transfer_packet" title="Permalink to this definition">¶</a></dt>
<dd><p>Override the transfertPacket method of Layer. Because
for a server that use the same tcpapplication for every client
the tcpsession to target is not the default me the right client.
So check if a client was sent in kwargs if it is the case send the
packet to the tcpsession of the client default otherwise</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pystack.layers.tcp_session">
<span id="tcp-session-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">tcp_session</span></tt> Module<a class="headerlink" href="#module-pystack.layers.tcp_session" title="Permalink to this headline">¶</a></h2>
<p>Author: Robin David
License: GNU GPLv3
Repo: <a class="reference external" href="https://github.com/RobinDavid">https://github.com/RobinDavid</a></p>
<p>Copyright (c) 2012 Robin David</p>
<p>PyStack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or 
any later version <a class="reference external" href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
<dl class="data">
<dt id="pystack.layers.tcp_session.FIN">
<tt class="descclassname">pystack.layers.tcp_session.</tt><tt class="descname">FIN</tt><em class="property"> = 1</em><a class="headerlink" href="#pystack.layers.tcp_session.FIN" title="Permalink to this definition">¶</a></dt>
<dd><p>FINACK = 17
SYNACK = 18
PSHACK = 24
RSTACK = 20</p>
</dd></dl>

<dl class="class">
<dt id="pystack.layers.tcp_session.State">
<em class="property">class </em><tt class="descclassname">pystack.layers.tcp_session.</tt><tt class="descname">State</tt><big>(</big><em>session</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_session.html#State"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_session.State" title="Permalink to this definition">¶</a></dt>
<dd><p>State class is the mother class that describe
a state at a given moment. A state is just
characterised by a name and should implement a 
method called packet_received that will provide 
the adapted state behavior for every packets</p>
<dl class="method">
<dt id="pystack.layers.tcp_session.State.packet_received">
<tt class="descname">packet_received</tt><big>(</big><em>packet</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_session.html#State.packet_received"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_session.State.packet_received" title="Permalink to this definition">¶</a></dt>
<dd><p>By default packet_received does nothing but
printing the packet</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pystack.layers.tcp_session.State_CLOSED">
<em class="property">class </em><tt class="descclassname">pystack.layers.tcp_session.</tt><tt class="descname">State_CLOSED</tt><big>(</big><em>session</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_session.html#State_CLOSED"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_session.State_CLOSED" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pystack.layers.tcp_session.State" title="pystack.layers.tcp_session.State"><tt class="xref py py-class docutils literal"><span class="pre">pystack.layers.tcp_session.State</span></tt></a></p>
<p>Any packets received on a Closed connection is
being replied with a reset packet</p>
<dl class="method">
<dt id="pystack.layers.tcp_session.State_CLOSED.packet_received">
<tt class="descname">packet_received</tt><big>(</big><em>packet</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_session.html#State_CLOSED.packet_received"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_session.State_CLOSED.packet_received" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pystack.layers.tcp_session.State_CLOSE_WAIT">
<em class="property">class </em><tt class="descclassname">pystack.layers.tcp_session.</tt><tt class="descname">State_CLOSE_WAIT</tt><big>(</big><em>session</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_session.html#State_CLOSE_WAIT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_session.State_CLOSE_WAIT" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pystack.layers.tcp_session.State" title="pystack.layers.tcp_session.State"><tt class="xref py py-class docutils literal"><span class="pre">pystack.layers.tcp_session.State</span></tt></a></p>
<p>This state is not implemented in the stack. The
stack always send both FIN and ACK in the same packet</p>
<dl class="method">
<dt id="pystack.layers.tcp_session.State_CLOSE_WAIT.packet_received">
<tt class="descname">packet_received</tt><big>(</big><em>packet</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_session.html#State_CLOSE_WAIT.packet_received"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_session.State_CLOSE_WAIT.packet_received" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pystack.layers.tcp_session.State_ESTABLISHED">
<em class="property">class </em><tt class="descclassname">pystack.layers.tcp_session.</tt><tt class="descname">State_ESTABLISHED</tt><big>(</big><em>session</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_session.html#State_ESTABLISHED"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_session.State_ESTABLISHED" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pystack.layers.tcp_session.State" title="pystack.layers.tcp_session.State"><tt class="xref py py-class docutils literal"><span class="pre">pystack.layers.tcp_session.State</span></tt></a></p>
<p>When the session is in the established state it should
handle a lot&#8217;s of different cases and react in consequences</p>
<dl class="method">
<dt id="pystack.layers.tcp_session.State_ESTABLISHED.packet_received">
<tt class="descname">packet_received</tt><big>(</big><em>packet</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_session.html#State_ESTABLISHED.packet_received"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_session.State_ESTABLISHED.packet_received" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pystack.layers.tcp_session.State_FIN_WAIT_1">
<em class="property">class </em><tt class="descclassname">pystack.layers.tcp_session.</tt><tt class="descname">State_FIN_WAIT_1</tt><big>(</big><em>session</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_session.html#State_FIN_WAIT_1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_session.State_FIN_WAIT_1" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pystack.layers.tcp_session.State" title="pystack.layers.tcp_session.State"><tt class="xref py py-class docutils literal"><span class="pre">pystack.layers.tcp_session.State</span></tt></a></p>
<p>When in FIN_WAIT expect a FIN and ACK packet. If
it received a FIN_ACK packet it sends a ACK switch to closed
and unregister itself from both the upper and the lower layer</p>
<dl class="method">
<dt id="pystack.layers.tcp_session.State_FIN_WAIT_1.packet_received">
<tt class="descname">packet_received</tt><big>(</big><em>packet</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_session.html#State_FIN_WAIT_1.packet_received"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_session.State_FIN_WAIT_1.packet_received" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pystack.layers.tcp_session.State_FIN_WAIT_2">
<em class="property">class </em><tt class="descclassname">pystack.layers.tcp_session.</tt><tt class="descname">State_FIN_WAIT_2</tt><big>(</big><em>session</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_session.html#State_FIN_WAIT_2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_session.State_FIN_WAIT_2" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pystack.layers.tcp_session.State" title="pystack.layers.tcp_session.State"><tt class="xref py py-class docutils literal"><span class="pre">pystack.layers.tcp_session.State</span></tt></a></p>
<p>In FIN_WAIT2 if the host send a FIN to session can be ended up
sucessfully.</p>
<dl class="method">
<dt id="pystack.layers.tcp_session.State_FIN_WAIT_2.packet_received">
<tt class="descname">packet_received</tt><big>(</big><em>packet</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_session.html#State_FIN_WAIT_2.packet_received"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_session.State_FIN_WAIT_2.packet_received" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pystack.layers.tcp_session.State_LAST_ACK">
<em class="property">class </em><tt class="descclassname">pystack.layers.tcp_session.</tt><tt class="descname">State_LAST_ACK</tt><big>(</big><em>session</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_session.html#State_LAST_ACK"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_session.State_LAST_ACK" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pystack.layers.tcp_session.State" title="pystack.layers.tcp_session.State"><tt class="xref py py-class docutils literal"><span class="pre">pystack.layers.tcp_session.State</span></tt></a></p>
<p>When in Last_ACK just wait for the final ack to close the connection</p>
<dl class="method">
<dt id="pystack.layers.tcp_session.State_LAST_ACK.packet_received">
<tt class="descname">packet_received</tt><big>(</big><em>packet</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_session.html#State_LAST_ACK.packet_received"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_session.State_LAST_ACK.packet_received" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pystack.layers.tcp_session.State_LISTEN">
<em class="property">class </em><tt class="descclassname">pystack.layers.tcp_session.</tt><tt class="descname">State_LISTEN</tt><big>(</big><em>session</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_session.html#State_LISTEN"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_session.State_LISTEN" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pystack.layers.tcp_session.State" title="pystack.layers.tcp_session.State"><tt class="xref py py-class docutils literal"><span class="pre">pystack.layers.tcp_session.State</span></tt></a></p>
<p>A tcp session in Listen state only process SYN packet. When a SYN
packet is received it checks that the number of connection to accept is
not exceeded. If this is ok it creates another TCP session specific for
this connection. Then it attachs it a TCPApplication either by forking
it or not depending of the config. Then it switched the newly created
connection to SYN_SENT state.</p>
<dl class="method">
<dt id="pystack.layers.tcp_session.State_LISTEN.packet_received">
<tt class="descname">packet_received</tt><big>(</big><em>packet</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_session.html#State_LISTEN.packet_received"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_session.State_LISTEN.packet_received" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pystack.layers.tcp_session.State_SYN_RCVD">
<em class="property">class </em><tt class="descclassname">pystack.layers.tcp_session.</tt><tt class="descname">State_SYN_RCVD</tt><big>(</big><em>session</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_session.html#State_SYN_RCVD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_session.State_SYN_RCVD" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pystack.layers.tcp_session.State" title="pystack.layers.tcp_session.State"><tt class="xref py py-class docutils literal"><span class="pre">pystack.layers.tcp_session.State</span></tt></a></p>
<p>When in SYN_RCVD only process ACK packets. Then
switch the state to ESTABLISHED and call ConnectionMade</p>
<dl class="method">
<dt id="pystack.layers.tcp_session.State_SYN_RCVD.packet_received">
<tt class="descname">packet_received</tt><big>(</big><em>packet</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_session.html#State_SYN_RCVD.packet_received"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_session.State_SYN_RCVD.packet_received" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pystack.layers.tcp_session.State_SYN_SENT">
<em class="property">class </em><tt class="descclassname">pystack.layers.tcp_session.</tt><tt class="descname">State_SYN_SENT</tt><big>(</big><em>session</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_session.html#State_SYN_SENT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_session.State_SYN_SENT" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pystack.layers.tcp_session.State" title="pystack.layers.tcp_session.State"><tt class="xref py py-class docutils literal"><span class="pre">pystack.layers.tcp_session.State</span></tt></a></p>
<p>When in SYN_SENT only process SYN_ACK packets by replying
a ACK packet. It also switch the state to ESTABLISHED and call
the session _call_connection_made method</p>
<dl class="method">
<dt id="pystack.layers.tcp_session.State_SYN_SENT.packet_received">
<tt class="descname">packet_received</tt><big>(</big><em>packet</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_session.html#State_SYN_SENT.packet_received"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_session.State_SYN_SENT.packet_received" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pystack.layers.tcp_session.State_TIME_WAIT">
<em class="property">class </em><tt class="descclassname">pystack.layers.tcp_session.</tt><tt class="descname">State_TIME_WAIT</tt><big>(</big><em>session</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_session.html#State_TIME_WAIT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_session.State_TIME_WAIT" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pystack.layers.tcp_session.State" title="pystack.layers.tcp_session.State"><tt class="xref py py-class docutils literal"><span class="pre">pystack.layers.tcp_session.State</span></tt></a></p>
<p>Not implemented state directly deleted (normally put to closed for few sec)</p>
</dd></dl>

<dl class="class">
<dt id="pystack.layers.tcp_session.TCPSession">
<em class="property">class </em><tt class="descclassname">pystack.layers.tcp_session.</tt><tt class="descname">TCPSession</tt><big>(</big><em>interface</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_session.html#TCPSession"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_session.TCPSession" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pystack.layers.layer.Layer" title="pystack.layers.layer.Layer"><tt class="xref py py-class docutils literal"><span class="pre">pystack.layers.layer.Layer</span></tt></a></p>
<p>TCPSession contains the core methods to deal with a lot of cases that can
be met with TCP. This class mainly implement methods to connect, bind and close
a TCP session with a remote host. At every moment a TCP session have a standardised
state from CLOSED, ESTABLISHED, ..
This class also keeps at every moment all the variables needed in order to process
TCP packets like sequence number, acknowledgement number, port ..</p>
<dl class="method">
<dt id="pystack.layers.tcp_session.TCPSession.accept">
<tt class="descname">accept</tt><big>(</big><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_session.html#TCPSession.accept"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_session.TCPSession.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>From a server point of view every client connections are hold
in the connections attribute. When accept is called the method start
by flushing all CLOSED connections from the connections list. Then it
waiting for a connection to be appended to the list to return it. (when
the currentconnection value is changed)</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.tcp_session.TCPSession.bind">
<tt class="descname">bind</tt><big>(</big><em>port</em>, <em>app=None</em>, <em>newinstance=False</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_session.html#TCPSession.bind"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_session.TCPSession.bind" title="Permalink to this definition">¶</a></dt>
<dd><p>The bind method is quite ligthweight. It justs register
itself to the TCP protocol as a handler and an entry is added
to iptables to prevent the Hosting host to reply with RST.
Note app and newinstance define on which TCPApplication client
connections should be redirected and if the TCPApplication should
be forked for every client or not.</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.tcp_session.TCPSession.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_session.html#TCPSession.close"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_session.TCPSession.close" title="Permalink to this definition">¶</a></dt>
<dd><p>For a client will send a FIN packet and switch to FIN_WAIT1.
For a server will send a FIN packet for every clients in order 
to unregister itself from the TCP layer</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.tcp_session.TCPSession.connect">
<tt class="descname">connect</tt><big>(</big><em>ip</em>, <em>port</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_session.html#TCPSession.connect"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_session.TCPSession.connect" title="Permalink to this definition">¶</a></dt>
<dd><p>This method try to connect to the given ip and port. If the
TCP session is not CLOSED the operations are aborted. Else a local
port is generated, an entry is added in iptables to preven the kernel
to disturbe our connection and then a SYN packet is sent. Then the
connection state is switched to SYN_SENT. The method will then loop
for 20 seconds checking if the state has changed to ESTABLISHED. If 
not it means that a problem occured and everything is rolled back.</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.tcp_session.TCPSession.listen">
<tt class="descname">listen</tt><big>(</big><em>nb=0</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_session.html#TCPSession.listen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_session.TCPSession.listen" title="Permalink to this definition">¶</a></dt>
<dd><p>This method basically just switch the current
state from CLOSED to LISTEN so that SYN request will
be handled.</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.tcp_session.TCPSession.packet_received">
<tt class="descname">packet_received</tt><big>(</big><em>packet</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_session.html#TCPSession.packet_received"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_session.TCPSession.packet_received" title="Permalink to this definition">¶</a></dt>
<dd><p>The more important thing with this method is that for each packet
this method can be called twice. The first time by the lower layer and the
packet is TCP. Then the packet is processed and packet_received is possibly
called once again with the packet decapsulated (in Raw). When a TCP packet
is received seq and ack value are updated when the packet_received method
of the current state of the connection is called to know what to do with 
the current packet.</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.tcp_session.TCPSession.sendRST">
<tt class="descname">sendRST</tt><big>(</big><em>packet</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_session.html#TCPSession.sendRST"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_session.TCPSession.sendRST" title="Permalink to this definition">¶</a></dt>
<dd><p>Just send a reset packet to the remote host</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.tcp_session.TCPSession.send_data">
<tt class="descname">send_data</tt><big>(</big><em>packet</em>, <em>push=True</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_session.html#TCPSession.send_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_session.TCPSession.send_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Just call send_packet with datas. The nextAck indicator
is also updated to the excpected value.</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.tcp_session.TCPSession.send_packet">
<tt class="descname">send_packet</tt><big>(</big><em>packet</em>, <em>flags=16</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_session.html#TCPSession.send_packet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_session.TCPSession.send_packet" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is one of the most critical. Every TCP packet are sent
through this method. This method basically deal with all the flags and
is in charge to incremente sequence number. In addition it sets all the
TCP fields in order to generate the packet. It increment the ack value
of the data size of the previously received packet.</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.tcp_session.TCPSession.switch_state">
<tt class="descname">switch_state</tt><big>(</big><em>state</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_session.html#TCPSession.switch_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_session.TCPSession.switch_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Switch to the given state. State should
implement State</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.tcp_session.TCPSession.transfer_packet">
<tt class="descname">transfer_packet</tt><big>(</big><em>packet</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_session.html#TCPSession.transfer_packet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_session.TCPSession.transfer_packet" title="Permalink to this definition">¶</a></dt>
<dd><p>Override the layer transfer_packet just to add the hook.</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.tcp_session.TCPSession.unregister_upper_layer">
<tt class="descname">unregister_upper_layer</tt><big>(</big><em>name</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/tcp_session.html#TCPSession.unregister_upper_layer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.tcp_session.TCPSession.unregister_upper_layer" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to remove himself from the lower layer</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pystack.layers.udp">
<span id="udp-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">udp</span></tt> Module<a class="headerlink" href="#module-pystack.layers.udp" title="Permalink to this headline">¶</a></h2>
<p>Author: Robin David
License: GNU GPLv3
Repo: <a class="reference external" href="https://github.com/RobinDavid">https://github.com/RobinDavid</a></p>
<p>Copyright (c) 2012 Robin David</p>
<p>PyStack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or 
any later version <a class="reference external" href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
<dl class="class">
<dt id="pystack.layers.udp.UDPProtocol">
<em class="property">class </em><tt class="descclassname">pystack.layers.udp.</tt><tt class="descname">UDPProtocol</tt><a class="reference internal" href="../modules/pystack/layers/udp.html#UDPProtocol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.udp.UDPProtocol" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pystack.layers.layer.Layer" title="pystack.layers.layer.Layer"><tt class="xref py py-class docutils literal"><span class="pre">pystack.layers.layer.Layer</span></tt></a></p>
<p>UDP Protocol provides basic functions of UDP. It
allow to send and receive UDP packet</p>
<dl class="method">
<dt id="pystack.layers.udp.UDPProtocol.forge_packet">
<tt class="descname">forge_packet</tt><big>(</big><em>packet</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/udp.html#UDPProtocol.forge_packet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.udp.UDPProtocol.forge_packet" title="Permalink to this definition">¶</a></dt>
<dd><p>Forge the packet with or without payload</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.udp.UDPProtocol.is_port_free">
<tt class="descname">is_port_free</tt><big>(</big><em>p</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/udp.html#UDPProtocol.is_port_free"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.udp.UDPProtocol.is_port_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Return either or not a port the given port is free</p>
</dd></dl>

<dl class="attribute">
<dt id="pystack.layers.udp.UDPProtocol.name">
<tt class="descname">name</tt><em class="property"> = 'UDP'</em><a class="headerlink" href="#pystack.layers.udp.UDPProtocol.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pystack.layers.udp.UDPProtocol.packet_received">
<tt class="descname">packet_received</tt><big>(</big><em>packet</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/udp.html#UDPProtocol.packet_received"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.udp.UDPProtocol.packet_received" title="Permalink to this definition">¶</a></dt>
<dd><p>When an UDP packet is received it is directly
forwarded to the associated application if it exists.</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.udp.UDPProtocol.send_packet">
<tt class="descname">send_packet</tt><big>(</big><em>packet</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/udp.html#UDPProtocol.send_packet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.udp.UDPProtocol.send_packet" title="Permalink to this definition">¶</a></dt>
<dd><p>Like in TCP send_packet call forge but without src and
dst which are IP123 fields.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pystack.layers.udp_application">
<span id="udp-application-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">udp_application</span></tt> Module<a class="headerlink" href="#module-pystack.layers.udp_application" title="Permalink to this headline">¶</a></h2>
<p>Author: Robin David
License: GNU GPLv3
Repo: <a class="reference external" href="https://github.com/RobinDavid">https://github.com/RobinDavid</a></p>
<p>Copyright (c) 2012 Robin David</p>
<p>PyStack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or 
any later version <a class="reference external" href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
<dl class="class">
<dt id="pystack.layers.udp_application.UDPApplication">
<em class="property">class </em><tt class="descclassname">pystack.layers.udp_application.</tt><tt class="descname">UDPApplication</tt><big>(</big><em>iface=None</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/udp_application.html#UDPApplication"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.udp_application.UDPApplication" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pystack.layers.layer.Layer" title="pystack.layers.layer.Layer"><tt class="xref py py-class docutils literal"><span class="pre">pystack.layers.layer.Layer</span></tt></a></p>
<p>UDP Application provides input output functionalities
above the UDP layer. An UDP application is directly linked
to the UDP layer (not like in TCP) because UDP is stateless</p>
<dl class="method">
<dt id="pystack.layers.udp_application.UDPApplication.bind">
<tt class="descname">bind</tt><big>(</big><em>port</em>, <em>app=None</em>, <em>fork=None</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/udp_application.html#UDPApplication.bind"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.udp_application.UDPApplication.bind" title="Permalink to this definition">¶</a></dt>
<dd><p>Bind like connect will register a handler in the UDP layer.
But it will also prevent the host to send ICMP host port unreachable</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.udp_application.UDPApplication.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="reference internal" href="../modules/pystack/layers/udp_application.html#UDPApplication.close"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.udp_application.UDPApplication.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close just unregister himself from the lower layer and
remove rules from iptables</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.udp_application.UDPApplication.connect">
<tt class="descname">connect</tt><big>(</big><em>ip</em>, <em>port</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/udp_application.html#UDPApplication.connect"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.udp_application.UDPApplication.connect" title="Permalink to this definition">¶</a></dt>
<dd><p>In UDP connect is not really meaningfull. In this
case it just means register an handler for the connection
in the UDP layer</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.udp_application.UDPApplication.fetch_data">
<tt class="descname">fetch_data</tt><big>(</big><em>size=None</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/udp_application.html#UDPApplication.fetch_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.udp_application.UDPApplication.fetch_data" title="Permalink to this definition">¶</a></dt>
<dd><p>fetch_data return the given number of bytes</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.udp_application.UDPApplication.fetch_data_from">
<tt class="descname">fetch_data_from</tt><big>(</big><em>size=None</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/udp_application.html#UDPApplication.fetch_data_from"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.udp_application.UDPApplication.fetch_data_from" title="Permalink to this definition">¶</a></dt>
<dd><p>fetch_data_from use the socket syntax and arguments. 
It returns the datas associated to the given host. Because
data in UDP is not a string this a list of string identified by
the remote IP.</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.udp_application.UDPApplication.get_conn_addr">
<tt class="descname">get_conn_addr</tt><big>(</big><big>)</big><a class="reference internal" href="../modules/pystack/layers/udp_application.html#UDPApplication.get_conn_addr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.udp_application.UDPApplication.get_conn_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return tuple of the remote IP remote port</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.udp_application.UDPApplication.get_self_addr">
<tt class="descname">get_self_addr</tt><big>(</big><big>)</big><a class="reference internal" href="../modules/pystack/layers/udp_application.html#UDPApplication.get_self_addr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.udp_application.UDPApplication.get_self_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the tuple of the local ip local port</p>
</dd></dl>

<dl class="attribute">
<dt id="pystack.layers.udp_application.UDPApplication.name">
<tt class="descname">name</tt><em class="property"> = 'Raw'</em><a class="headerlink" href="#pystack.layers.udp_application.UDPApplication.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pystack.layers.udp_application.UDPApplication.packet_received">
<tt class="descname">packet_received</tt><big>(</big><em>packet</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/udp_application.html#UDPApplication.packet_received"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.udp_application.UDPApplication.packet_received" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the received datas to the buffer data. The mutex
prevent any improper read/write</p>
</dd></dl>

<dl class="method">
<dt id="pystack.layers.udp_application.UDPApplication.send_packet">
<tt class="descname">send_packet</tt><big>(</big><em>packet</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pystack/layers/udp_application.html#UDPApplication.send_packet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pystack.layers.udp_application.UDPApplication.send_packet" title="Permalink to this definition">¶</a></dt>
<dd><p>Sending a packet to an host does not require any
connection or any call to connect. So if a packet is the 
first for a destination host. Associated rules are added in
iptables. Then every fields are setup in order to call the 
transfer it to the lowest layer</p>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<h3><a href="../index.html">Table Of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../text/intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../text/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../text/framework.html">Framework Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../text/usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../text/example.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../text/devel.html">PyStack development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../text/compliance.html">IP Stack compliance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../text/troubleshoot.html">Troubleshooting</a></li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/api/pystack.layers.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="relbar-bottom">
        
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> &nbsp; &nbsp;</li>
    <li><a href="../index.html">PyStack 1 documentation</a> &raquo;</li>
 
      </ul>
    </div>
    </div>

    <div class="footer">
        &copy; Copyright 2013, Robin David.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
    <!-- cloud_sptheme 1.4 -->
  </body>
</html>
